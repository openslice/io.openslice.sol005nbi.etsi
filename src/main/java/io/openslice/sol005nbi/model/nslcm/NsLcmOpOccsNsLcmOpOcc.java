/*
 * SOL005 - NS Lifecycle Management Interface
 * SOL005 - NS Lifecycle Management Interface IMPORTANT: Please note that this file might be not aligned to the current version of the ETSI Group Specification it refers to and has not been approved by the ETSI NFV ISG. In case of discrepancies the published ETSI Group Specification takes precedence. Please report bugs to https://forge.etsi.org/bugzilla/buglist.cgi?component=Nfv-Openapis 
 *
 * OpenAPI spec version: 1.3.0-impl:etsi.org:ETSI_NFV_OpenAPI:1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.openslice.sol005nbi.model.nslcm;

import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;

import io.openslice.sol005nbi.model.vnf.InlineResponse400;
import io.swagger.v3.oas.annotations.media.Schema;
/**
 * This type represents a request a NS lifecycle operation occurrence. It shall comply with the provisions defined in Table 6.5.2.3-1. 
 */
@Schema(description = "This type represents a request a NS lifecycle operation occurrence. It shall comply with the provisions defined in Table 6.5.2.3-1. ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-28T00:48:29.393+02:00[Europe/Athens]")
public class NsLcmOpOccsNsLcmOpOcc {
  @JsonProperty("id")
  private String id = null;

  /**
   * The enumeration NsLcmOperationStateType shall comply with the provisions defined in Table 6.5.4.4-1. Value | Description ------|------------ PROCESSING | The LCM operation is currently in execution. COMPLETED | The LCM operation has been completed successfully. PARTIALLY_COMPLETED | The LCM operation has been partially completed with accepTable errors. FAILED_TEMP | The LCM operation has failed and execution has stopped, but the execution of the operation is not considered to be closed. FAILED | The LCM operation has failed and it cannot be retried or rolled back, as it is determined that such action won&#x27;t succeed. OLLING_BACK | The LCM operation is currently being rolled back. ROLLED_BACK | The LCM operation has been successfully rolled back, i.e. The state of the VNF prior to the original operation invocation has been restored as closely as possible. 
   */
  public enum OperationStateEnum {
    PROCESSING("PROCESSING"),
    COMPLETED("COMPLETED"),
    FAILED_TEMP("FAILED_TEMP"),
    FAILED("FAILED"),
    ROLLING_BACK("ROLLING_BACK"),
    ROLLED_BACK("ROLLED_BACK");

    private String value;

    OperationStateEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static OperationStateEnum fromValue(String text) {
      for (OperationStateEnum b : OperationStateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("operationState")
  private OperationStateEnum operationState = null;

  @JsonProperty("statusEnteredTime")
  private Object statusEnteredTime = null;

  @JsonProperty("nsInstanceId")
  private String nsInstanceId = null;

  /**
   * The enumeration NsLcmOpType represents those lifecycle operations that trigger a NS lifecycle management operation occurrence notification. Value | Description ------|------------ INSTANTIATE | Represents the \&quot;Instantiate NS\&quot; LCM operation. SCALE | Represents the \&quot;Scale NS\&quot; LCM operation. UPDATE | Represents the \&quot;Update NS\&quot; LCM operation. TERMINATE | Represents the \&quot;Terminate NS\&quot; LCM operation. HEAL | Represents the \&quot;Heal NS\&quot; LCM operation. 
   */
  public enum LcmOperationTypeEnum {
    INSTANTIATE("INSTANTIATE"),
    SCALE("SCALE"),
    UPDATE("UPDATE"),
    TERMINATE("TERMINATE"),
    HEAL("HEAL");

    private String value;

    LcmOperationTypeEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static LcmOperationTypeEnum fromValue(String text) {
      for (LcmOperationTypeEnum b : LcmOperationTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("lcmOperationType")
  private LcmOperationTypeEnum lcmOperationType = null;

  @JsonProperty("startTime")
  private Object startTime = null;

  @JsonProperty("isAutomaticInvocation")
  private Boolean isAutomaticInvocation = null;

  /**
   * Input parameters of the LCM operation. This attribute shall be formatted according to the request data type of the related LCM operation. The following mapping between lcmOperationType and the data type of this attribute shall apply: - INSTANTIATE: InstantiateNsRequest - SCALE: ScaleNsRequest - UPDATE: UpdateNsRequest - HEAL: HealNsRequest - TERMINATE: TerminateNsRequest This attribute shall be present if this data type is returned in a response to reading an individual resource, and may be present according to the chosen attribute selector parameter if this data type is returned in a response to a query of a container resource. 
   */
  public enum OperationParamsEnum {
    INSTANTIATE("INSTANTIATE"),
    SCALE("SCALE"),
    UPDATE("UPDATE"),
    HEAL("HEAL"),
    TERMINATE("TERMINATE");

    private String value;

    OperationParamsEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static OperationParamsEnum fromValue(String text) {
      for (OperationParamsEnum b : OperationParamsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("operationParams")
  private OperationParamsEnum operationParams = null;

  @JsonProperty("isCancelPending")
  private Boolean isCancelPending = null;

  /**
   * Cancellation mode. The NFVO shall not start any new VNF lifecycle management and resource management operation, and shall wait for the ongoing VNF lifecycle management and resource management operations in the underlying system, typically the VNFM and VIM, to finish execution or to time out. After that, the NFVO shall put the operation occurrence into the FAILED_TEMP state. The NFVO shall not start any new VNF lifecycle management and resource management operation, shall cancel the ongoing VNF lifecycle management and resource management operations in the underlying system, typically the VNFM and VIM, and shall wait for the cancellation to finish or to time out. After that, the NFVO shall put the operation occurrence into the FAILED_TEMP state. 
   */
  public enum CancelModeEnum {
    GRACEFUL("GRACEFUL"),
    FORCEFUL("FORCEFUL");

    private String value;

    CancelModeEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static CancelModeEnum fromValue(String text) {
      for (CancelModeEnum b : CancelModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("cancelMode")
  private CancelModeEnum cancelMode = null;

  @JsonProperty("error")
  private InlineResponse400 error = null;

  @JsonProperty("resourceChanges")
  private NsLcmOpOccsNsLcmOpOccResourceChanges resourceChanges = null;

  @JsonProperty("_links")
  private NsLcmOpOccsNsLcmOpOccLinks _links = null;

  public NsLcmOpOccsNsLcmOpOcc id(String id) {
    this.id = id;
    return this;
  }

   /**
   * An identifier with the intention of being globally unique. 
   * @return id
  **/
  @Schema(required = true, description = "An identifier with the intention of being globally unique. ")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public NsLcmOpOccsNsLcmOpOcc operationState(OperationStateEnum operationState) {
    this.operationState = operationState;
    return this;
  }

   /**
   * The enumeration NsLcmOperationStateType shall comply with the provisions defined in Table 6.5.4.4-1. Value | Description ------|------------ PROCESSING | The LCM operation is currently in execution. COMPLETED | The LCM operation has been completed successfully. PARTIALLY_COMPLETED | The LCM operation has been partially completed with accepTable errors. FAILED_TEMP | The LCM operation has failed and execution has stopped, but the execution of the operation is not considered to be closed. FAILED | The LCM operation has failed and it cannot be retried or rolled back, as it is determined that such action won&#x27;t succeed. OLLING_BACK | The LCM operation is currently being rolled back. ROLLED_BACK | The LCM operation has been successfully rolled back, i.e. The state of the VNF prior to the original operation invocation has been restored as closely as possible. 
   * @return operationState
  **/
  @Schema(required = true, description = "The enumeration NsLcmOperationStateType shall comply with the provisions defined in Table 6.5.4.4-1. Value | Description ------|------------ PROCESSING | The LCM operation is currently in execution. COMPLETED | The LCM operation has been completed successfully. PARTIALLY_COMPLETED | The LCM operation has been partially completed with accepTable errors. FAILED_TEMP | The LCM operation has failed and execution has stopped, but the execution of the operation is not considered to be closed. FAILED | The LCM operation has failed and it cannot be retried or rolled back, as it is determined that such action won't succeed. OLLING_BACK | The LCM operation is currently being rolled back. ROLLED_BACK | The LCM operation has been successfully rolled back, i.e. The state of the VNF prior to the original operation invocation has been restored as closely as possible. ")
  public OperationStateEnum getOperationState() {
    return operationState;
  }

  public void setOperationState(OperationStateEnum operationState) {
    this.operationState = operationState;
  }

  public NsLcmOpOccsNsLcmOpOcc statusEnteredTime(Object statusEnteredTime) {
    this.statusEnteredTime = statusEnteredTime;
    return this;
  }

   /**
   * Date-time stamp. Representation: String formatted according toas defined by the date-time production in IETF RFC 3339. 
   * @return statusEnteredTime
  **/
  @Schema(required = true, description = "Date-time stamp. Representation: String formatted according toas defined by the date-time production in IETF RFC 3339. ")
  public Object getStatusEnteredTime() {
    return statusEnteredTime;
  }

  public void setStatusEnteredTime(Object statusEnteredTime) {
    this.statusEnteredTime = statusEnteredTime;
  }

  public NsLcmOpOccsNsLcmOpOcc nsInstanceId(String nsInstanceId) {
    this.nsInstanceId = nsInstanceId;
    return this;
  }

   /**
   * An identifier with the intention of being globally unique. 
   * @return nsInstanceId
  **/
  @Schema(required = true, description = "An identifier with the intention of being globally unique. ")
  public String getNsInstanceId() {
    return nsInstanceId;
  }

  public void setNsInstanceId(String nsInstanceId) {
    this.nsInstanceId = nsInstanceId;
  }

  public NsLcmOpOccsNsLcmOpOcc lcmOperationType(LcmOperationTypeEnum lcmOperationType) {
    this.lcmOperationType = lcmOperationType;
    return this;
  }

   /**
   * The enumeration NsLcmOpType represents those lifecycle operations that trigger a NS lifecycle management operation occurrence notification. Value | Description ------|------------ INSTANTIATE | Represents the \&quot;Instantiate NS\&quot; LCM operation. SCALE | Represents the \&quot;Scale NS\&quot; LCM operation. UPDATE | Represents the \&quot;Update NS\&quot; LCM operation. TERMINATE | Represents the \&quot;Terminate NS\&quot; LCM operation. HEAL | Represents the \&quot;Heal NS\&quot; LCM operation. 
   * @return lcmOperationType
  **/
  @Schema(required = true, description = "The enumeration NsLcmOpType represents those lifecycle operations that trigger a NS lifecycle management operation occurrence notification. Value | Description ------|------------ INSTANTIATE | Represents the \"Instantiate NS\" LCM operation. SCALE | Represents the \"Scale NS\" LCM operation. UPDATE | Represents the \"Update NS\" LCM operation. TERMINATE | Represents the \"Terminate NS\" LCM operation. HEAL | Represents the \"Heal NS\" LCM operation. ")
  public LcmOperationTypeEnum getLcmOperationType() {
    return lcmOperationType;
  }

  public void setLcmOperationType(LcmOperationTypeEnum lcmOperationType) {
    this.lcmOperationType = lcmOperationType;
  }

  public NsLcmOpOccsNsLcmOpOcc startTime(Object startTime) {
    this.startTime = startTime;
    return this;
  }

   /**
   * Date-time stamp. Representation: String formatted according toas defined by the date-time production in IETF RFC 3339. 
   * @return startTime
  **/
  @Schema(required = true, description = "Date-time stamp. Representation: String formatted according toas defined by the date-time production in IETF RFC 3339. ")
  public Object getStartTime() {
    return startTime;
  }

  public void setStartTime(Object startTime) {
    this.startTime = startTime;
  }

  public NsLcmOpOccsNsLcmOpOcc isAutomaticInvocation(Boolean isAutomaticInvocation) {
    this.isAutomaticInvocation = isAutomaticInvocation;
    return this;
  }

   /**
   * Set to true if this NS LCM operation occurrence has been automatically triggered by the NFVO. This occurs in the case of auto-scaling, auto-healing and when a nested NS is modified as a result of an operation on its composite NS. Set to false otherwise. 
   * @return isAutomaticInvocation
  **/
  @Schema(required = true, description = "Set to true if this NS LCM operation occurrence has been automatically triggered by the NFVO. This occurs in the case of auto-scaling, auto-healing and when a nested NS is modified as a result of an operation on its composite NS. Set to false otherwise. ")
  public Boolean isIsAutomaticInvocation() {
    return isAutomaticInvocation;
  }

  public void setIsAutomaticInvocation(Boolean isAutomaticInvocation) {
    this.isAutomaticInvocation = isAutomaticInvocation;
  }

  public NsLcmOpOccsNsLcmOpOcc operationParams(OperationParamsEnum operationParams) {
    this.operationParams = operationParams;
    return this;
  }

   /**
   * Input parameters of the LCM operation. This attribute shall be formatted according to the request data type of the related LCM operation. The following mapping between lcmOperationType and the data type of this attribute shall apply: - INSTANTIATE: InstantiateNsRequest - SCALE: ScaleNsRequest - UPDATE: UpdateNsRequest - HEAL: HealNsRequest - TERMINATE: TerminateNsRequest This attribute shall be present if this data type is returned in a response to reading an individual resource, and may be present according to the chosen attribute selector parameter if this data type is returned in a response to a query of a container resource. 
   * @return operationParams
  **/
  @Schema(description = "Input parameters of the LCM operation. This attribute shall be formatted according to the request data type of the related LCM operation. The following mapping between lcmOperationType and the data type of this attribute shall apply: - INSTANTIATE: InstantiateNsRequest - SCALE: ScaleNsRequest - UPDATE: UpdateNsRequest - HEAL: HealNsRequest - TERMINATE: TerminateNsRequest This attribute shall be present if this data type is returned in a response to reading an individual resource, and may be present according to the chosen attribute selector parameter if this data type is returned in a response to a query of a container resource. ")
  public OperationParamsEnum getOperationParams() {
    return operationParams;
  }

  public void setOperationParams(OperationParamsEnum operationParams) {
    this.operationParams = operationParams;
  }

  public NsLcmOpOccsNsLcmOpOcc isCancelPending(Boolean isCancelPending) {
    this.isCancelPending = isCancelPending;
    return this;
  }

   /**
   * If the LCM operation occurrence is in \&quot;PROCESSING\&quot; or \&quot;ROLLING_BACK\&quot; state and the operation is being cancelled, this attribute shall be set to true. Otherwise, it shall be set to false. 
   * @return isCancelPending
  **/
  @Schema(required = true, description = "If the LCM operation occurrence is in \"PROCESSING\" or \"ROLLING_BACK\" state and the operation is being cancelled, this attribute shall be set to true. Otherwise, it shall be set to false. ")
  public Boolean isIsCancelPending() {
    return isCancelPending;
  }

  public void setIsCancelPending(Boolean isCancelPending) {
    this.isCancelPending = isCancelPending;
  }

  public NsLcmOpOccsNsLcmOpOcc cancelMode(CancelModeEnum cancelMode) {
    this.cancelMode = cancelMode;
    return this;
  }

   /**
   * Cancellation mode. The NFVO shall not start any new VNF lifecycle management and resource management operation, and shall wait for the ongoing VNF lifecycle management and resource management operations in the underlying system, typically the VNFM and VIM, to finish execution or to time out. After that, the NFVO shall put the operation occurrence into the FAILED_TEMP state. The NFVO shall not start any new VNF lifecycle management and resource management operation, shall cancel the ongoing VNF lifecycle management and resource management operations in the underlying system, typically the VNFM and VIM, and shall wait for the cancellation to finish or to time out. After that, the NFVO shall put the operation occurrence into the FAILED_TEMP state. 
   * @return cancelMode
  **/
  @Schema(description = "Cancellation mode. The NFVO shall not start any new VNF lifecycle management and resource management operation, and shall wait for the ongoing VNF lifecycle management and resource management operations in the underlying system, typically the VNFM and VIM, to finish execution or to time out. After that, the NFVO shall put the operation occurrence into the FAILED_TEMP state. The NFVO shall not start any new VNF lifecycle management and resource management operation, shall cancel the ongoing VNF lifecycle management and resource management operations in the underlying system, typically the VNFM and VIM, and shall wait for the cancellation to finish or to time out. After that, the NFVO shall put the operation occurrence into the FAILED_TEMP state. ")
  public CancelModeEnum getCancelMode() {
    return cancelMode;
  }

  public void setCancelMode(CancelModeEnum cancelMode) {
    this.cancelMode = cancelMode;
  }

  public NsLcmOpOccsNsLcmOpOcc error(InlineResponse400 error) {
    this.error = error;
    return this;
  }

   /**
   * Get error
   * @return error
  **/
  @Schema(description = "")
  public InlineResponse400 getError() {
    return error;
  }

  public void setError(InlineResponse400 error) {
    this.error = error;
  }

  public NsLcmOpOccsNsLcmOpOcc resourceChanges(NsLcmOpOccsNsLcmOpOccResourceChanges resourceChanges) {
    this.resourceChanges = resourceChanges;
    return this;
  }

   /**
   * Get resourceChanges
   * @return resourceChanges
  **/
  @Schema(description = "")
  public NsLcmOpOccsNsLcmOpOccResourceChanges getResourceChanges() {
    return resourceChanges;
  }

  public void setResourceChanges(NsLcmOpOccsNsLcmOpOccResourceChanges resourceChanges) {
    this.resourceChanges = resourceChanges;
  }

  public NsLcmOpOccsNsLcmOpOcc _links(NsLcmOpOccsNsLcmOpOccLinks _links) {
    this._links = _links;
    return this;
  }

   /**
   * Get _links
   * @return _links
  **/
  @Schema(required = true, description = "")
  public NsLcmOpOccsNsLcmOpOccLinks getLinks() {
    return _links;
  }

  public void setLinks(NsLcmOpOccsNsLcmOpOccLinks _links) {
    this._links = _links;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NsLcmOpOccsNsLcmOpOcc nsLcmOpOccsNsLcmOpOcc = (NsLcmOpOccsNsLcmOpOcc) o;
    return Objects.equals(this.id, nsLcmOpOccsNsLcmOpOcc.id) &&
        Objects.equals(this.operationState, nsLcmOpOccsNsLcmOpOcc.operationState) &&
        Objects.equals(this.statusEnteredTime, nsLcmOpOccsNsLcmOpOcc.statusEnteredTime) &&
        Objects.equals(this.nsInstanceId, nsLcmOpOccsNsLcmOpOcc.nsInstanceId) &&
        Objects.equals(this.lcmOperationType, nsLcmOpOccsNsLcmOpOcc.lcmOperationType) &&
        Objects.equals(this.startTime, nsLcmOpOccsNsLcmOpOcc.startTime) &&
        Objects.equals(this.isAutomaticInvocation, nsLcmOpOccsNsLcmOpOcc.isAutomaticInvocation) &&
        Objects.equals(this.operationParams, nsLcmOpOccsNsLcmOpOcc.operationParams) &&
        Objects.equals(this.isCancelPending, nsLcmOpOccsNsLcmOpOcc.isCancelPending) &&
        Objects.equals(this.cancelMode, nsLcmOpOccsNsLcmOpOcc.cancelMode) &&
        Objects.equals(this.error, nsLcmOpOccsNsLcmOpOcc.error) &&
        Objects.equals(this.resourceChanges, nsLcmOpOccsNsLcmOpOcc.resourceChanges) &&
        Objects.equals(this._links, nsLcmOpOccsNsLcmOpOcc._links);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, operationState, statusEnteredTime, nsInstanceId, lcmOperationType, startTime, isAutomaticInvocation, operationParams, isCancelPending, cancelMode, error, resourceChanges, _links);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NsLcmOpOccsNsLcmOpOcc {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    operationState: ").append(toIndentedString(operationState)).append("\n");
    sb.append("    statusEnteredTime: ").append(toIndentedString(statusEnteredTime)).append("\n");
    sb.append("    nsInstanceId: ").append(toIndentedString(nsInstanceId)).append("\n");
    sb.append("    lcmOperationType: ").append(toIndentedString(lcmOperationType)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    isAutomaticInvocation: ").append(toIndentedString(isAutomaticInvocation)).append("\n");
    sb.append("    operationParams: ").append(toIndentedString(operationParams)).append("\n");
    sb.append("    isCancelPending: ").append(toIndentedString(isCancelPending)).append("\n");
    sb.append("    cancelMode: ").append(toIndentedString(cancelMode)).append("\n");
    sb.append("    error: ").append(toIndentedString(error)).append("\n");
    sb.append("    resourceChanges: ").append(toIndentedString(resourceChanges)).append("\n");
    sb.append("    _links: ").append(toIndentedString(_links)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
