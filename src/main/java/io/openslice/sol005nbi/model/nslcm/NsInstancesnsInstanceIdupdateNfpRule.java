/*
 * SOL005 - NS Lifecycle Management Interface
 * SOL005 - NS Lifecycle Management Interface IMPORTANT: Please note that this file might be not aligned to the current version of the ETSI Group Specification it refers to and has not been approved by the ETSI NFV ISG. In case of discrepancies the published ETSI Group Specification takes precedence. Please report bugs to https://forge.etsi.org/bugzilla/buglist.cgi?component=Nfv-Openapis 
 *
 * OpenAPI spec version: 1.3.0-impl:etsi.org:ETSI_NFV_OpenAPI:1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.openslice.sol005nbi.model.nslcm;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;

import io.swagger.v3.oas.annotations.media.Schema;
/**
 * The NfpRule data type is an expression of the conditions that shall be met in order for the NFP to be applicable to the packet. The condition acts as a flow classifier and it is met only if all the values expressed in the condition are matched by those in the packet. It shall comply with the provisions defined in Table 6.5.3.40-1. 
 */
@Schema(description = "The NfpRule data type is an expression of the conditions that shall be met in order for the NFP to be applicable to the packet. The condition acts as a flow classifier and it is met only if all the values expressed in the condition are matched by those in the packet. It shall comply with the provisions defined in Table 6.5.3.40-1. ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-28T00:48:29.393+02:00[Europe/Athens]")
public class NsInstancesnsInstanceIdupdateNfpRule {
  @JsonProperty("etherDestinationAddress")
  private String etherDestinationAddress = null;

  @JsonProperty("etherSourceAddress")
  private String etherSourceAddress = null;

  /**
   * Human readable description for the VNFFG. 
   */
  public enum EtherTypeEnum {
    IPV4("IPV4"),
    IPV6("IPV6");

    private String value;

    EtherTypeEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static EtherTypeEnum fromValue(String text) {
      for (EtherTypeEnum b : EtherTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("etherType")
  private EtherTypeEnum etherType = null;

  @JsonProperty("vlanTag")
  private List<String> vlanTag = null;

  /**
   * Indicates the L4 protocol, For IPv4 [7] this corresponds to the field called \&quot;Protocol\&quot; to identify the next level protocol. For IPv6 [28] this corresponds to the field is called the \&quot;Next Header\&quot; field. Permitted values: Any keyword defined in the IANA protocol registry [1], e.g.: TCP UDP ICMP 
   */
  public enum ProtocolEnum {
    TCP("TCP"),
    UDP("UDP"),
    ICMP("ICMP");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static ProtocolEnum fromValue(String text) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("protocol")
  private ProtocolEnum protocol = null;

  @JsonProperty("dscp")
  private String dscp = null;

  @JsonProperty("sourcePortRange")
  private NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange sourcePortRange = null;

  @JsonProperty("destinationPortRange")
  private NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange destinationPortRange = null;

  @JsonProperty("sourceIpAddressPrefix")
  private String sourceIpAddressPrefix = null;

  @JsonProperty("destinationIpAddressPrefix")
  private String destinationIpAddressPrefix = null;

  @JsonProperty("extendedCriteria")
  private List<NsInstancesnsInstanceIdupdateNfpRuleExtendedCriteria> extendedCriteria = null;

  public NsInstancesnsInstanceIdupdateNfpRule etherDestinationAddress(String etherDestinationAddress) {
    this.etherDestinationAddress = etherDestinationAddress;
    return this;
  }

   /**
   * A MAC address. Representation: string that consists of groups of two hexadecimal digits, separated by hyphens or colons. 
   * @return etherDestinationAddress
  **/
  @Schema(description = "A MAC address. Representation: string that consists of groups of two hexadecimal digits, separated by hyphens or colons. ")
  public String getEtherDestinationAddress() {
    return etherDestinationAddress;
  }

  public void setEtherDestinationAddress(String etherDestinationAddress) {
    this.etherDestinationAddress = etherDestinationAddress;
  }

  public NsInstancesnsInstanceIdupdateNfpRule etherSourceAddress(String etherSourceAddress) {
    this.etherSourceAddress = etherSourceAddress;
    return this;
  }

   /**
   * A MAC address. Representation: string that consists of groups of two hexadecimal digits, separated by hyphens or colons. 
   * @return etherSourceAddress
  **/
  @Schema(description = "A MAC address. Representation: string that consists of groups of two hexadecimal digits, separated by hyphens or colons. ")
  public String getEtherSourceAddress() {
    return etherSourceAddress;
  }

  public void setEtherSourceAddress(String etherSourceAddress) {
    this.etherSourceAddress = etherSourceAddress;
  }

  public NsInstancesnsInstanceIdupdateNfpRule etherType(EtherTypeEnum etherType) {
    this.etherType = etherType;
    return this;
  }

   /**
   * Human readable description for the VNFFG. 
   * @return etherType
  **/
  @Schema(description = "Human readable description for the VNFFG. ")
  public EtherTypeEnum getEtherType() {
    return etherType;
  }

  public void setEtherType(EtherTypeEnum etherType) {
    this.etherType = etherType;
  }

  public NsInstancesnsInstanceIdupdateNfpRule vlanTag(List<String> vlanTag) {
    this.vlanTag = vlanTag;
    return this;
  }

  public NsInstancesnsInstanceIdupdateNfpRule addVlanTagItem(String vlanTagItem) {
    if (this.vlanTag == null) {
      this.vlanTag = new ArrayList<>();
    }
    this.vlanTag.add(vlanTagItem);
    return this;
  }

   /**
   * Indicates a VLAN identifier in an IEEE 802.1Q-2018 tag [6] Multiple tags can be included for QinQ stacking. See note. 
   * @return vlanTag
  **/
  @Schema(description = "Indicates a VLAN identifier in an IEEE 802.1Q-2018 tag [6] Multiple tags can be included for QinQ stacking. See note. ")
  public List<String> getVlanTag() {
    return vlanTag;
  }

  public void setVlanTag(List<String> vlanTag) {
    this.vlanTag = vlanTag;
  }

  public NsInstancesnsInstanceIdupdateNfpRule protocol(ProtocolEnum protocol) {
    this.protocol = protocol;
    return this;
  }

   /**
   * Indicates the L4 protocol, For IPv4 [7] this corresponds to the field called \&quot;Protocol\&quot; to identify the next level protocol. For IPv6 [28] this corresponds to the field is called the \&quot;Next Header\&quot; field. Permitted values: Any keyword defined in the IANA protocol registry [1], e.g.: TCP UDP ICMP 
   * @return protocol
  **/
  @Schema(description = "Indicates the L4 protocol, For IPv4 [7] this corresponds to the field called \"Protocol\" to identify the next level protocol. For IPv6 [28] this corresponds to the field is called the \"Next Header\" field. Permitted values: Any keyword defined in the IANA protocol registry [1], e.g.: TCP UDP ICMP ")
  public ProtocolEnum getProtocol() {
    return protocol;
  }

  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }

  public NsInstancesnsInstanceIdupdateNfpRule dscp(String dscp) {
    this.dscp = dscp;
    return this;
  }

   /**
   * For IPv4 [7] a string of \&quot;0\&quot; and \&quot;1\&quot; digits that corresponds to the 6-bit Differentiated Services Code Point (DSCP) field of the IP header. For IPv6 [28] a string of \&quot;0\&quot; and \&quot;1\&quot; digits that corresponds to the 6 differentiated services bits of the traffic class header field 
   * @return dscp
  **/
  @Schema(description = "For IPv4 [7] a string of \"0\" and \"1\" digits that corresponds to the 6-bit Differentiated Services Code Point (DSCP) field of the IP header. For IPv6 [28] a string of \"0\" and \"1\" digits that corresponds to the 6 differentiated services bits of the traffic class header field ")
  public String getDscp() {
    return dscp;
  }

  public void setDscp(String dscp) {
    this.dscp = dscp;
  }

  public NsInstancesnsInstanceIdupdateNfpRule sourcePortRange(NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange sourcePortRange) {
    this.sourcePortRange = sourcePortRange;
    return this;
  }

   /**
   * Get sourcePortRange
   * @return sourcePortRange
  **/
  @Schema(description = "")
  public NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange getSourcePortRange() {
    return sourcePortRange;
  }

  public void setSourcePortRange(NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange sourcePortRange) {
    this.sourcePortRange = sourcePortRange;
  }

  public NsInstancesnsInstanceIdupdateNfpRule destinationPortRange(NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange destinationPortRange) {
    this.destinationPortRange = destinationPortRange;
    return this;
  }

   /**
   * Get destinationPortRange
   * @return destinationPortRange
  **/
  @Schema(description = "")
  public NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange getDestinationPortRange() {
    return destinationPortRange;
  }

  public void setDestinationPortRange(NsInstancesnsInstanceIdupdateNfpRuleSourcePortRange destinationPortRange) {
    this.destinationPortRange = destinationPortRange;
  }

  public NsInstancesnsInstanceIdupdateNfpRule sourceIpAddressPrefix(String sourceIpAddressPrefix) {
    this.sourceIpAddressPrefix = sourceIpAddressPrefix;
    return this;
  }

   /**
   * An IPV4 or IPV6 address range in CIDR format. For IPV4 address range, refer to IETF RFC 4632 [12]. For IPV6 address range, refer to IETF RFC 4291. 
   * @return sourceIpAddressPrefix
  **/
  @Schema(description = "An IPV4 or IPV6 address range in CIDR format. For IPV4 address range, refer to IETF RFC 4632 [12]. For IPV6 address range, refer to IETF RFC 4291. ")
  public String getSourceIpAddressPrefix() {
    return sourceIpAddressPrefix;
  }

  public void setSourceIpAddressPrefix(String sourceIpAddressPrefix) {
    this.sourceIpAddressPrefix = sourceIpAddressPrefix;
  }

  public NsInstancesnsInstanceIdupdateNfpRule destinationIpAddressPrefix(String destinationIpAddressPrefix) {
    this.destinationIpAddressPrefix = destinationIpAddressPrefix;
    return this;
  }

   /**
   * An IPV4 or IPV6 address range in CIDR format. For IPV4 address range, refer to IETF RFC 4632 [12]. For IPV6 address range, refer to IETF RFC 4291. 
   * @return destinationIpAddressPrefix
  **/
  @Schema(description = "An IPV4 or IPV6 address range in CIDR format. For IPV4 address range, refer to IETF RFC 4632 [12]. For IPV6 address range, refer to IETF RFC 4291. ")
  public String getDestinationIpAddressPrefix() {
    return destinationIpAddressPrefix;
  }

  public void setDestinationIpAddressPrefix(String destinationIpAddressPrefix) {
    this.destinationIpAddressPrefix = destinationIpAddressPrefix;
  }

  public NsInstancesnsInstanceIdupdateNfpRule extendedCriteria(List<NsInstancesnsInstanceIdupdateNfpRuleExtendedCriteria> extendedCriteria) {
    this.extendedCriteria = extendedCriteria;
    return this;
  }

  public NsInstancesnsInstanceIdupdateNfpRule addExtendedCriteriaItem(NsInstancesnsInstanceIdupdateNfpRuleExtendedCriteria extendedCriteriaItem) {
    if (this.extendedCriteria == null) {
      this.extendedCriteria = new ArrayList<>();
    }
    this.extendedCriteria.add(extendedCriteriaItem);
    return this;
  }

   /**
   * Indicates values of specific bits in a frame. 
   * @return extendedCriteria
  **/
  @Schema(description = "Indicates values of specific bits in a frame. ")
  public List<NsInstancesnsInstanceIdupdateNfpRuleExtendedCriteria> getExtendedCriteria() {
    return extendedCriteria;
  }

  public void setExtendedCriteria(List<NsInstancesnsInstanceIdupdateNfpRuleExtendedCriteria> extendedCriteria) {
    this.extendedCriteria = extendedCriteria;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NsInstancesnsInstanceIdupdateNfpRule nsInstancesnsInstanceIdupdateNfpRule = (NsInstancesnsInstanceIdupdateNfpRule) o;
    return Objects.equals(this.etherDestinationAddress, nsInstancesnsInstanceIdupdateNfpRule.etherDestinationAddress) &&
        Objects.equals(this.etherSourceAddress, nsInstancesnsInstanceIdupdateNfpRule.etherSourceAddress) &&
        Objects.equals(this.etherType, nsInstancesnsInstanceIdupdateNfpRule.etherType) &&
        Objects.equals(this.vlanTag, nsInstancesnsInstanceIdupdateNfpRule.vlanTag) &&
        Objects.equals(this.protocol, nsInstancesnsInstanceIdupdateNfpRule.protocol) &&
        Objects.equals(this.dscp, nsInstancesnsInstanceIdupdateNfpRule.dscp) &&
        Objects.equals(this.sourcePortRange, nsInstancesnsInstanceIdupdateNfpRule.sourcePortRange) &&
        Objects.equals(this.destinationPortRange, nsInstancesnsInstanceIdupdateNfpRule.destinationPortRange) &&
        Objects.equals(this.sourceIpAddressPrefix, nsInstancesnsInstanceIdupdateNfpRule.sourceIpAddressPrefix) &&
        Objects.equals(this.destinationIpAddressPrefix, nsInstancesnsInstanceIdupdateNfpRule.destinationIpAddressPrefix) &&
        Objects.equals(this.extendedCriteria, nsInstancesnsInstanceIdupdateNfpRule.extendedCriteria);
  }

  @Override
  public int hashCode() {
    return Objects.hash(etherDestinationAddress, etherSourceAddress, etherType, vlanTag, protocol, dscp, sourcePortRange, destinationPortRange, sourceIpAddressPrefix, destinationIpAddressPrefix, extendedCriteria);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NsInstancesnsInstanceIdupdateNfpRule {\n");
    
    sb.append("    etherDestinationAddress: ").append(toIndentedString(etherDestinationAddress)).append("\n");
    sb.append("    etherSourceAddress: ").append(toIndentedString(etherSourceAddress)).append("\n");
    sb.append("    etherType: ").append(toIndentedString(etherType)).append("\n");
    sb.append("    vlanTag: ").append(toIndentedString(vlanTag)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    dscp: ").append(toIndentedString(dscp)).append("\n");
    sb.append("    sourcePortRange: ").append(toIndentedString(sourcePortRange)).append("\n");
    sb.append("    destinationPortRange: ").append(toIndentedString(destinationPortRange)).append("\n");
    sb.append("    sourceIpAddressPrefix: ").append(toIndentedString(sourceIpAddressPrefix)).append("\n");
    sb.append("    destinationIpAddressPrefix: ").append(toIndentedString(destinationIpAddressPrefix)).append("\n");
    sb.append("    extendedCriteria: ").append(toIndentedString(extendedCriteria)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
