/*
 * SOL005 - VNF Package Management Interface
 * SOL005 - VNF Package Management Interface IMPORTANT: Please note that this file might be not aligned to the current version of the ETSI Group Specification it refers to and has not been approved by the ETSI NFV ISG. In case of discrepancies the published ETSI Group Specification takes precedence. Please report bugs to https://forge.etsi.org/bugzilla/buglist.cgi?component=Nfv-Openapis 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.openslice.sol005nbi.model.vnf;

import java.util.Date;
import java.util.Objects;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;

import io.swagger.v3.oas.annotations.media.Schema;
/**
 * This type represents an artifact contained in a VNF package which represents a software image.   
 */
@Schema(description = "This type represents an artifact contained in a VNF package which represents a software image.   ")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-20T00:01:04.793+02:00[Europe/Athens]")
public class VnfPackagesVnfPkgInfoSoftwareImages {
  @JsonProperty("id")
  private String id = null;

  @JsonProperty("name")
  private String name = null;

  @JsonProperty("provider")
  private String provider = null;

  @JsonProperty("version")
  private String version = null;

  @JsonProperty("checksum")
  private VnfPackagesVnfPkgInfoChecksum checksum = null;

  /**
   * Container format indicates whether the software image is in a file format that also contains meta-data about the actual software. Permitted values: - AKI: a kernel image format - AMI: a machine image format - ARI: a ram disk image format - BARE: the image does not have a container or meta-data envelope - DOCKER: docker container format - OVA: OVF package in a tar file - OVF: OVF container format 
   */
  public enum ContainerFormatEnum {
    AKI("AKI"),
    AMI("AMI"),
    ARI("ARI"),
    BARE("BARE"),
    DOCKER("DOCKER"),
    OVA("OVA"),
    OVF("OVF");

    private String value;

    ContainerFormatEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static ContainerFormatEnum fromValue(String text) {
      for (ContainerFormatEnum b : ContainerFormatEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("containerFormat")
  private ContainerFormatEnum containerFormat = null;

  /**
   * Disk format of a software image is the format of the underlying disk image. Permitted values: - AKI: a kernel image format - AMI: a machine image format - ARI: a ramdisk image format - ISO: an archive format for the data contents of an optical disc, such as CD-ROM - QCOW2: a common disk image format, which can expand dynamically and supports copy on write - RAW: an unstructured disk image format - VDI: a common disk image format - VHD: a common disk image format - VHDX: enhanced version of VHD format - VMDK: a common disk image format 
   */
  public enum DiskFormatEnum {
    AKI("AKI"),
    AMI("AMI"),
    ARI("ARI"),
    ISO("ISO"),
    QCOW2("QCOW2"),
    RAW("RAW"),
    VDI("VDI"),
    VHD("VHD"),
    VHDX("VHDX"),
    VMDK("VMDK");

    private String value;

    DiskFormatEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static DiskFormatEnum fromValue(String text) {
      for (DiskFormatEnum b : DiskFormatEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("diskFormat")
  private DiskFormatEnum diskFormat = null;

  @JsonProperty("createdAt")   
  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy hh:mm:ss")
  private Date  createdAt = null;

  @JsonProperty("minDisk")
  private Integer minDisk = null;

  @JsonProperty("minRam")
  private Integer minRam = null;

  @JsonProperty("size")
  private Integer size = null;

  @JsonProperty("userMetadata")
  private Object userMetadata = null;

  @JsonProperty("imagePath")
  private String imagePath = null;

  public VnfPackagesVnfPkgInfoSoftwareImages id(String id) {
    this.id = id;
    return this;
  }

   /**
   * Identifier of the software image. 
   * @return id
  **/
  @Schema(required = true, description = "Identifier of the software image. ")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the software image. 
   * @return name
  **/
  @Schema(required = true, description = "Name of the software image. ")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages provider(String provider) {
    this.provider = provider;
    return this;
  }

   /**
   * Provider of the software image. 
   * @return provider
  **/
  @Schema(required = true, description = "Provider of the software image. ")
  public String getProvider() {
    return provider;
  }

  public void setProvider(String provider) {
    this.provider = provider;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages version(String version) {
    this.version = version;
    return this;
  }

   /**
   * Software version of the VNF. This is changed when there is any change to the software included in the VNF package. This information is copied from the VNFD. It shall be present after the VNF package content has been on-boarded and absent otherwise. 
   * @return version
  **/
  @Schema(required = true, description = "Software version of the VNF. This is changed when there is any change to the software included in the VNF package. This information is copied from the VNFD. It shall be present after the VNF package content has been on-boarded and absent otherwise. ")
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages checksum(VnfPackagesVnfPkgInfoChecksum checksum) {
    this.checksum = checksum;
    return this;
  }

   /**
   * Get checksum
   * @return checksum
  **/
  @Schema(required = true, description = "")
  public VnfPackagesVnfPkgInfoChecksum getChecksum() {
    return checksum;
  }

  public void setChecksum(VnfPackagesVnfPkgInfoChecksum checksum) {
    this.checksum = checksum;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages containerFormat(ContainerFormatEnum containerFormat) {
    this.containerFormat = containerFormat;
    return this;
  }

   /**
   * Container format indicates whether the software image is in a file format that also contains meta-data about the actual software. Permitted values: - AKI: a kernel image format - AMI: a machine image format - ARI: a ram disk image format - BARE: the image does not have a container or meta-data envelope - DOCKER: docker container format - OVA: OVF package in a tar file - OVF: OVF container format 
   * @return containerFormat
  **/
  @Schema(required = true, description = "Container format indicates whether the software image is in a file format that also contains meta-data about the actual software. Permitted values: - AKI: a kernel image format - AMI: a machine image format - ARI: a ram disk image format - BARE: the image does not have a container or meta-data envelope - DOCKER: docker container format - OVA: OVF package in a tar file - OVF: OVF container format ")
  public ContainerFormatEnum getContainerFormat() {
    return containerFormat;
  }

  public void setContainerFormat(ContainerFormatEnum containerFormat) {
    this.containerFormat = containerFormat;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages diskFormat(DiskFormatEnum diskFormat) {
    this.diskFormat = diskFormat;
    return this;
  }

   /**
   * Disk format of a software image is the format of the underlying disk image. Permitted values: - AKI: a kernel image format - AMI: a machine image format - ARI: a ramdisk image format - ISO: an archive format for the data contents of an optical disc, such as CD-ROM - QCOW2: a common disk image format, which can expand dynamically and supports copy on write - RAW: an unstructured disk image format - VDI: a common disk image format - VHD: a common disk image format - VHDX: enhanced version of VHD format - VMDK: a common disk image format 
   * @return diskFormat
  **/
  @Schema(required = true, description = "Disk format of a software image is the format of the underlying disk image. Permitted values: - AKI: a kernel image format - AMI: a machine image format - ARI: a ramdisk image format - ISO: an archive format for the data contents of an optical disc, such as CD-ROM - QCOW2: a common disk image format, which can expand dynamically and supports copy on write - RAW: an unstructured disk image format - VDI: a common disk image format - VHD: a common disk image format - VHDX: enhanced version of VHD format - VMDK: a common disk image format ")
  public DiskFormatEnum getDiskFormat() {
    return diskFormat;
  }

  public void setDiskFormat(DiskFormatEnum diskFormat) {
    this.diskFormat = diskFormat;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages createdAt( Date createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * Date-time stamp.  Representation: String formatted according to IETF RFC 3339. 
   * @return createdAt
  **/
  @Schema(required = true, description = "Date-time stamp.  Representation: String formatted according to IETF RFC 3339. ")
  public Date getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt( Date createdAt) {
    this.createdAt = createdAt;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages minDisk(Integer minDisk) {
    this.minDisk = minDisk;
    return this;
  }

   /**
   * The minimal disk for this software image in bytes. 
   * minimum: 0
   * @return minDisk
  **/
  @Schema(required = true, description = "The minimal disk for this software image in bytes. ")
  public Integer getMinDisk() {
    return minDisk;
  }

  public void setMinDisk(Integer minDisk) {
    this.minDisk = minDisk;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages minRam(Integer minRam) {
    this.minRam = minRam;
    return this;
  }

   /**
   * The minimal RAM for this software image in bytes. 
   * minimum: 0
   * @return minRam
  **/
  @Schema(required = true, description = "The minimal RAM for this software image in bytes. ")
  public Integer getMinRam() {
    return minRam;
  }

  public void setMinRam(Integer minRam) {
    this.minRam = minRam;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages size(Integer size) {
    this.size = size;
    return this;
  }

   /**
   * Size of this software image in bytes. 
   * minimum: 0
   * @return size
  **/
  @Schema(required = true, description = "Size of this software image in bytes. ")
  public Integer getSize() {
    return size;
  }

  public void setSize(Integer size) {
    this.size = size;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages userMetadata(Object userMetadata) {
    this.userMetadata = userMetadata;
    return this;
  }

   /**
   * This type represents a list of key-value pairs. The order of the pairs in the list is not significant. In JSON, a set of key- value pairs is represented as an object. It shall comply with the provisions  defined in clause 4 of IETF RFC 7159.  
   * @return userMetadata
  **/
  @Schema(description = "This type represents a list of key-value pairs. The order of the pairs in the list is not significant. In JSON, a set of key- value pairs is represented as an object. It shall comply with the provisions  defined in clause 4 of IETF RFC 7159.  ")
  public Object getUserMetadata() {
    return userMetadata;
  }

  public void setUserMetadata(Object userMetadata) {
    this.userMetadata = userMetadata;
  }

  public VnfPackagesVnfPkgInfoSoftwareImages imagePath(String imagePath) {
    this.imagePath = imagePath;
    return this;
  }

   /**
   * Path in the VNF package, which identifies the image artifact and also allows to access a copy of the image artifact. 
   * @return imagePath
  **/
  @Schema(required = true, description = "Path in the VNF package, which identifies the image artifact and also allows to access a copy of the image artifact. ")
  public String getImagePath() {
    return imagePath;
  }

  public void setImagePath(String imagePath) {
    this.imagePath = imagePath;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VnfPackagesVnfPkgInfoSoftwareImages vnfPackagesVnfPkgInfoSoftwareImages = (VnfPackagesVnfPkgInfoSoftwareImages) o;
    return Objects.equals(this.id, vnfPackagesVnfPkgInfoSoftwareImages.id) &&
        Objects.equals(this.name, vnfPackagesVnfPkgInfoSoftwareImages.name) &&
        Objects.equals(this.provider, vnfPackagesVnfPkgInfoSoftwareImages.provider) &&
        Objects.equals(this.version, vnfPackagesVnfPkgInfoSoftwareImages.version) &&
        Objects.equals(this.checksum, vnfPackagesVnfPkgInfoSoftwareImages.checksum) &&
        Objects.equals(this.containerFormat, vnfPackagesVnfPkgInfoSoftwareImages.containerFormat) &&
        Objects.equals(this.diskFormat, vnfPackagesVnfPkgInfoSoftwareImages.diskFormat) &&
        Objects.equals(this.createdAt, vnfPackagesVnfPkgInfoSoftwareImages.createdAt) &&
        Objects.equals(this.minDisk, vnfPackagesVnfPkgInfoSoftwareImages.minDisk) &&
        Objects.equals(this.minRam, vnfPackagesVnfPkgInfoSoftwareImages.minRam) &&
        Objects.equals(this.size, vnfPackagesVnfPkgInfoSoftwareImages.size) &&
        Objects.equals(this.userMetadata, vnfPackagesVnfPkgInfoSoftwareImages.userMetadata) &&
        Objects.equals(this.imagePath, vnfPackagesVnfPkgInfoSoftwareImages.imagePath);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, provider, version, checksum, containerFormat, diskFormat, createdAt, minDisk, minRam, size, userMetadata, imagePath);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VnfPackagesVnfPkgInfoSoftwareImages {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    provider: ").append(toIndentedString(provider)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    checksum: ").append(toIndentedString(checksum)).append("\n");
    sb.append("    containerFormat: ").append(toIndentedString(containerFormat)).append("\n");
    sb.append("    diskFormat: ").append(toIndentedString(diskFormat)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    minDisk: ").append(toIndentedString(minDisk)).append("\n");
    sb.append("    minRam: ").append(toIndentedString(minRam)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    userMetadata: ").append(toIndentedString(userMetadata)).append("\n");
    sb.append("    imagePath: ").append(toIndentedString(imagePath)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
